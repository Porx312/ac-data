'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dgram = require('dgram');

var dgram = _interopRequireWildcard(_dgram);

var _events = require('events');

var _HandshakerResponseParser = require('ac-remote-telemetry-client/lib/parsers/HandshakerResponseParser');

var _HandshakerResponseParser2 = _interopRequireDefault(_HandshakerResponseParser);

var _RTCarInfoParser = require('ac-remote-telemetry-client/lib/parsers/RTCarInfoParser');

var _RTCarInfoParser2 = _interopRequireDefault(_RTCarInfoParser);

var _RTLapParser = require('ac-remote-telemetry-client/lib/parsers/RTLapParser');

var _RTLapParser2 = _interopRequireDefault(_RTLapParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // AC Remote Telemetry specification https://docs.google.com/document/d/1KfkZiIluXZ6mMhLWfDX1qAGbvhGRC3ZUzjVIt5FQpp4/pub

/**
 * The connection port number of the Assetto Corsa server (ACServer)
 *
 * @type {number}
 */
var AC_SERVER_PORT = 9996;

/**
 * [not used in the current Remote Telemetry version by AC] In future version this field will identify the AC Remote Telemetry version that the device expects to speak with.
 *
 * @type {number}
 */
var AC_SERVER_VERSION = 1;

/**
 * [not used in the current Remote Telemetry version by AC] In future versions it will identify the platform type of the client.
 * This will be used to adjust a specific behaviour for each platform.
 *
 * @type {{eAndroidTablet: number, eIPhoneDevice: number, eIPadDevice: number, eAndroidPhone: number}}
 */
var deviceIdentifier = {
  eIPhoneDevice: 0,
  eIPadDevice: 1,
  eAndroidPhone: 2,
  eAndroidTablet: 3
};

/**
 * This is the type of operation required by the client. The following operations are now available:
 * HANDSHAKE: This operation identifier must be set when the client wants to start the communication.
 * SUBSCRIBE_UPDATE: This operation identifier must be set when the client wants to be updated from the specific ACServer.
 * SUBSCRIBE_SPOT: This operation identifier must be set when the client wants to be updated from the specific ACServer just for SPOT Events (e.g.: the end of a lap).
 * DISMISS: This operation identifier must be set when the client wants to leave the communication with ACServer.
 *
 * @type {{DISMISS: number, SUBSCRIBE_SPOT: number, HANDSHAKE: number, SUBSCRIBE_UPDATE: number}}
 */
var operation = {
  HANDSHAKE: 0,
  SUBSCRIBE_UPDATE: 1,
  SUBSCRIBE_SPOT: 2,
  DISMISS: 3
};

/**
 * Constants representing the events emitted by the client
 *
 * @type {{HANDSHAKER_RESPONSE: string, RT_LAP: string, RT_CAR_INFO: string}}
 */
var event = {
  HANDSHAKER_RESPONSE: 'HANDSHAKER_RESPONSE',
  RT_CAR_INFO: 'RT_CAR_INFO',
  RT_LAP: 'RT_LAP'
};

var ACRemoteTelemetryClient = function (_EventEmitter) {
  _inherits(ACRemoteTelemetryClient, _EventEmitter);

  /**
     * The ACRemoteTelemetryClient constructor
     * @param acServerId
     */
  function ACRemoteTelemetryClient(acServerId) {
    _classCallCheck(this, ACRemoteTelemetryClient);

    var _this = _possibleConstructorReturn(this, (ACRemoteTelemetryClient.__proto__ || Object.getPrototypeOf(ACRemoteTelemetryClient)).call(this));

    _this.acServerIp = acServerId;
    _this.client = dgram.createSocket('udp4');
    return _this;
  }

  /**
     * Start listening for messages.
     */


  _createClass(ACRemoteTelemetryClient, [{
    key: 'start',
    value: function start() {
      var _this2 = this;

      if (!this.client) {
        return;
      }

      this.client.on('listening', function () {
        console.log('UDP Client listening on ' + _this2.acServerIp + ':' + AC_SERVER_PORT + ' \uD83C\uDFCE');
      });

      this.client.on('message', function (msg, rinfo) {
        _this2.parseMessage(msg, rinfo);
      });
    }

    /**
       * Close the client.
       */

  }, {
    key: 'stop',
    value: function stop() {
      var _this3 = this;

      if (!this.client) {
        return;
      }

      this.client.close(function () {
        console.log('UDP Client closed ðŸ');
        _this3.client = null;
      });
    }

    /**
       *
       * @param op
       * @param identifier
       * @param version
       */

  }, {
    key: 'sendHandshaker',
    value: function sendHandshaker(op) {
      var identifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : deviceIdentifier.eIPhoneDevice;
      var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AC_SERVER_VERSION;

      var message = Buffer.alloc(12);

      message.writeInt32LE(identifier, 0);
      message.writeInt32LE(version, 4);
      message.writeInt32LE(op, 8);

      this.client.send(message, 0, message.length, AC_SERVER_PORT, this.acServerIp);
    }

    /**
       *
       */

  }, {
    key: 'handshake',
    value: function handshake() {
      this.sendHandshaker(operation.HANDSHAKE);
    }

    /**
       *
       */

  }, {
    key: 'subscribeUpdate',
    value: function subscribeUpdate() {
      this.sendHandshaker(operation.SUBSCRIBE_UPDATE);
    }

    /**
       *
       */

  }, {
    key: 'subscribeSpot',
    value: function subscribeSpot() {
      this.sendHandshaker(operation.SUBSCRIBE_SPOT);
    }

    /**
       *
       */

  }, {
    key: 'dismiss',
    value: function dismiss() {
      this.sendHandshaker(operation.DISMISS);
    }

    /**
       *
       * @param msg
       * @param rinfo
       */

  }, {
    key: 'parseMessage',
    value: function parseMessage(msg, rinfo) {
      switch (rinfo.size) {
        case 408:
          this.emit(event.HANDSHAKER_RESPONSE, new _HandshakerResponseParser2.default().fromBuffer(msg));
          break;
        case 328:
          this.emit(event.RT_CAR_INFO, new _RTCarInfoParser2.default().fromBuffer(msg));
          break;
        case 212:
          this.emit(event.RT_LAP, new _RTLapParser2.default(msg).fromBuffer(msg));
          break;
        default:
      }
    }
  }]);

  return ACRemoteTelemetryClient;
}(_events.EventEmitter);

module.exports = ACRemoteTelemetryClient;